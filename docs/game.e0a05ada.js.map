{"version":3,"sources":["src/services/rendering/Node2D.ts","src/constants.ts","src/services/rendering/Tile.ts","src/utils/index.ts","src/services/rendering/Scene.ts","src/services/rendering/Renderer.ts","src/services/rendering/index.ts","src/services/input.ts","src/services/rendering/Group.ts","src/services/game/grid.ts","src/game.ts"],"names":[],"mappings":"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","file":"game.e0a05ada.js","sourceRoot":"..","sourcesContent":["import { Node2DInterface, Point } from '../../types';\n\nexport abstract class Node2D implements Node2DInterface {\n    size?: Point;\n    children?: Node2DInterface[];\n    onClick?: (point: Point) => void;\n    parent?: Node2DInterface;\n\n    constructor(public position: Point) {}\n\n    getPosition(): Point {\n        const position: Point = [...this.position] as Point;\n        if (this.parent) {\n            const parentPosition = this.parent.getPosition();\n\n            position[0] += parentPosition[0];\n            position[1] += parentPosition[1];\n        }\n\n        return position;\n    }\n\n    draw(context: CanvasRenderingContext2D): void {\n        throw new Error('Method not implemented.');\n    }\n}\n","export const Colors = [\n    '#EC392B',\n    '#4958A6',\n    '#3AAD52',\n    '#1F1E18',\n    '#F2DC53'\n]","import { Point } from '../../types';\nimport { Node2D } from './Node2D';\nimport { Colors } from '../../constants';\n\nexport class Tile extends Node2D {\n    size: Point = [0, 0];\n    padding: number = 10;\n    onClick: (point: Point) => void = null;\n\n    constructor(public position: Point, size: number, public type: number) {\n        super(position);\n\n        this.size = [size, size];\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        const {\n            position: [x, y],\n            size,\n            type,\n        } = this;\n\n        const [w, h] = size.map((x: number) => x - this.padding);\n\n        context.save();\n        context.fillStyle = Colors[type];\n        context.fillRect(x, y, w, h);\n\n        context.shadowColor = `${Colors[type]}33`; // string\n        //Color of the shadow;  RGB, RGBA, HSL, HEX, and other inputs are valid.\n        context.shadowOffsetX = 0; // integer\n        //Horizontal distance of the shadow, in relation to the text.\n        context.shadowOffsetY = 0; // integer\n        //Vertical distance of the shadow, in relation to the text.\n        context.shadowBlur = 20; // integer\n        context.globalCompositeOperation = 'source-atop';\n\n        context.strokeRect(x, y, w, h);\n        context.strokeRect(x, y, w, h);\n        context.strokeRect(x, y, w, h);\n        context.strokeRect(x, y, w, h);\n        context.strokeRect(x, y, w, h);\n        context.restore();\n    }\n}\n","import { Node2DInterface, Point, TileMatrix } from '../types';\n\nfunction isBetween(x: number, x0: number, x1: number): boolean {\n    return x >= x0 && x <= x1;\n}\n\nexport function isIntersecting(point: Point, obj: Node2DInterface) {\n    const [x, y] = point;\n    const [x0, y0] = obj.getPosition();\n    const [x1, y1] = [obj.size[0] + x0, obj.size[1] + y0];\n\n    return isBetween(x, x0, x1) && isBetween(y, y0, y1);\n}\n\nexport function shuffle<T>(arr: Array<T>): Array<T> {\n    return [...arr].sort(() => Math.random() - 0.5);\n}\n\nexport function splitArray<T>(arr: Array<T>, size: number): Array<Array<T>> {\n    const matrix: Array<Array<T>> = [];\n    let row: Array<T>;\n    arr.forEach((item, i) => {\n        if (i % size === 0) {\n            row = [];\n            matrix.push(row);\n        }\n\n        row.push(item);\n\n        return row;\n    }, []);\n\n    return matrix;\n}\n\nexport function compareMatrix(\n    matrix0: TileMatrix,\n    matrix1: TileMatrix\n): boolean {\n    return matrix0.every((row, y) =>\n        row.every((tile, x) => matrix1[y][x] === tile)\n    );\n}\n\nexport function createTileMatrix(size = 5, full: boolean = false) {\n    let arr = [];\n    for (let i = 0; i < size ** 2; i++) arr.push(i % size);\n\n    arr = shuffle(arr);\n\n    if (!full) {\n        arr.splice(-1, 1, -1);\n    }\n\n    console.log(arr);\n\n    return splitArray(arr, size);\n}\n","import { Point, Node2DInterface } from '../../types';\nimport { isIntersecting } from '../../utils';\n\nexport class Scene {\n    children: Array<Node2DInterface> = [];\n    background: string = null;\n\n    add(obj: Node2DInterface) {\n        this.children.push(obj);\n    }\n\n    intersectNodes(point: Point) {\n        const intersections: Array<Node2DInterface> = [];\n        const nodes = [...this.children];\n\n        while (nodes.length) {\n            const node = nodes.shift();\n\n            if (node.children) {\n                nodes.push(...node.children);\n            } else if (isIntersecting(point, node)) {\n                intersections.push(node);\n            }\n        }\n\n        return intersections;\n    }\n}\n","import { Scene } from './Scene';\nimport { Node2DInterface } from '../../types';\n\nexport class Renderer {\n    context: CanvasRenderingContext2D;\n    canvas: HTMLCanvasElement;\n\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.context = this.canvas.getContext('2d');\n    }\n\n    drawBackground(color: string) {\n        const { context, canvas } = this;\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        context.fillStyle = color;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    drawNodes(Nodes: Array<Node2DInterface>) {\n        Nodes.forEach(obj => obj.draw(this.context));\n    }\n\n    clear() {\n        const { context, canvas } = this;\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    render(scene: Scene) {\n        const { context, canvas } = this;\n        // const scale = getScale(canvas);\n\n        // context.imageSmoothingEnabled = scale < 1;\n        // context.setTransform(\n        //     scale,\n        //     0,\n        //     0,\n        //     scale,\n        //     0, 0\n        // );\n\n        if (scene.background) this.drawBackground(scene.background);\n\n        this.drawNodes(scene.children);\n    }\n\n    setSize(w: number, h: number) {\n        this.canvas.width = Math.floor(w);\n        this.canvas.height = Math.floor(h);\n    }\n\n    get size() {\n        return [this.canvas.width, this.canvas.height];\n    }\n}\n","export * from './Tile';\nexport * from './Scene';\nexport * from './Renderer';","import { Scene } from './rendering';\nimport { Point } from '../types';\n\nfunction getRelativeCoords(e: MouseEvent): Point {\n    const target = e.target as HTMLCanvasElement;\n    return [\n        (e.pageX - target.offsetLeft),\n        (e.pageY - target.offsetTop)\n    ]\n}\n\nexport class InputHandler {\n    constructor(public canvas: HTMLCanvasElement, public scene: Scene) {\n        canvas.addEventListener('click', this.handleClick);\n        // canvas.addEventListener('pointerdown', this.handleClick);\n    }\n\n    handleClick = (e: MouseEvent) => {\n        e.preventDefault();\n\n        const { canvas, scene } = this;\n        const { width, height, clientWidth, clientHeight } = canvas;\n\n        const scaleX = width / clientWidth;\n        const scaleY = height / clientHeight;\n        const point: Point = getRelativeCoords(e);\n\n        point[0] *= scaleX;\n        point[1] *= scaleY;\n\n        const nodes = scene.intersectNodes(point);\n\n        nodes.forEach(node => {\n            node.onClick && node.onClick(point);\n        });\n    };\n}\n","import { Node2D } from \"./Node2D\";\n\nexport class Group extends Node2D {\n    children: Array<Node2D> = [];\n\n    add(node: Node2D) {\n        this.children.push(node);\n        node.parent = this;\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        context.save();\n\n        context.translate(...this.position);\n        this.children.forEach(node => node.draw(context));\n        context.restore();\n    }\n}","import { Group } from '../rendering/Group';\nimport { Point, TileMatrix } from '../../types';\nimport { Tile } from '../rendering';\nimport { createTileMatrix } from '../../utils';\n\nfunction isEmptyTile(matrix: TileMatrix, x: number, y: number) {\n    return (\n        y >= 0 &&\n        y < matrix.length &&\n        x >= 0 &&\n        x < matrix[y].length &&\n        matrix[y][x] === -1\n    );\n}\n\nexport class Grid extends Group {\n    tileMatrix: Array<Array<number>>;\n    isEnabled: boolean = true;\n    isUpdated: boolean = false;\n\n    constructor(\n        position: Point,\n        public tileSize: number = 50,\n        public gridSize: number = 5,\n        public full: boolean = false\n    ) {\n        super(position);\n\n        this.tileMatrix = createTileMatrix(gridSize, full);\n\n        this.tileMatrix.forEach((row, y) => {\n            row.forEach((type, x) => {\n                if (type === -1) return;\n\n                const tile = new Tile(\n                    [tileSize * x, tileSize * y],\n                    tileSize,\n                    type\n                );\n\n                tile.onClick = this.handleClick.bind(this, {\n                    type,\n                    tile,\n                    x,\n                    y,\n                });\n\n                this.add(tile);\n            });\n        });\n    }\n\n    handleClick({\n        x,\n        y,\n        tile,\n        type,\n    }: {\n        x: number;\n        y: number;\n        tile: Tile;\n        type: number;\n    }) {\n        if (!this.isEnabled) return false;\n\n        const { tileMatrix, tileSize } = this;\n\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].some(([xDir, yDir]: Point) => {\n            const newX = x + xDir;\n            const newY = y + yDir;\n\n            if (!isEmptyTile(tileMatrix, newX, newY)) return false;\n\n            tileMatrix[newY][newX] = type;\n            tileMatrix[y][x] = -1;\n\n            tile.position = [tileSize * newX, tileSize * newY];\n            tile.onClick = this.handleClick.bind(this, {\n                type,\n                tile,\n                x: newX,\n                y: newY,\n            });\n\n            return true;\n        });\n\n        this.isUpdated = true;\n    }\n}\n","import { Renderer, Scene, Tile } from './services/rendering';\nimport { InputHandler } from './services/input';\nimport { Grid } from './services/game/grid';\nimport { compareMatrix, createTileMatrix } from './utils';\n\nconst renderer = new Renderer();\nrenderer.setSize(1080, 1920);\n// renderer.setSize(canvas.clientWidth, canvas.clientHeight);\n\nconst scene = new Scene();\nscene.background = '#eeeeee';\n\nconst inputHandler = new InputHandler(renderer.canvas, scene);\n\nconst grid = new Grid([140, 40], 160);\nscene.add(grid);\n\nconst expectGrid = new Grid([300, 1200], 160, 3, true);\nexpectGrid.isEnabled = false;\nscene.add(expectGrid);\n\n\nconst loop = () => {\n    requestAnimationFrame(loop);\n\n    renderer.render(scene);\n\n    if (grid.isUpdated) {\n        if (\n            compareMatrix(\n                expectGrid.tileMatrix,\n                grid.tileMatrix.slice(1, 4).map(r => r.slice(1, 4))\n            )\n        ) {\n            alert('you won');\n        }\n        grid.isUpdated = false;\n    }\n};\nloop();\n\ndocument.body.appendChild(renderer.canvas);\n"]}